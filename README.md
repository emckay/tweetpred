# Tweet Pred

This repo contains the code to run [TweetPred](https://tweetpred.surge.sh).

![alt text](https://github.com/emckay/tweetpred/blob/master/tweetpred_screenshot.png)


## Code organization

The code is organized as follows:

* `front_end/` - React application that fetches and displays data to the user
* `jobs/` - AWS Lambda job that runs on a regular basis to calculate up-to-date estimates
* `tweetpred_django/` - Root Django configuration directory
* `twitter_models/` - Django REST Framework application that is responsible for generating and aggregating estimations and predictions
* `twitter_models/hawkes/` - Implementation of [Hawkes Point Process model](http://mathworld.wolfram.com/HawkesProcess.html)

## Application information

This application is meant to assist people trading on [PredictIt](https://www.predictit.org)'s weekly Tweet count markets.

It uses the [Hawkes Point Process model](http://mathworld.wolfram.com/HawkesProcess.html) to predict how many Tweets will be generated by Twitter accounts controlled by Donald Trump and other White House staff.

## Infrastructure

Every four hours, the latest data is fetched from Twitter, the model parameters are estimated, and 250 predictions are generated. The estimates and predictions are stored in a PostgreSQL database hosted on AWS RDS.

When a user visits the front-end, one request is sent to the server for each account. The server aggregates the predictions into a histogram form and the front-end React application renders that to the user.

The application is deployed on a serverless infrastructure on AWS Lambda as well as on a traditional server on Heroku. The front-end application sends its requests to the Heroku server, but the estimates and predictions are calculated by the Lambda endpoints. The Lambda endpoints are a bit slower per-request, but they make horizontal scaling trivial for the estimate calculation (i.e. it is just as fast to calculate 250 predictions as 1000 predictions).

## Current state of the application

This codebase is very immature at the moment. Development speed was prioritized over robustness and configurability.
